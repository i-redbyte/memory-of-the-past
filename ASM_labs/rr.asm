;СЕГМЕНТ ДАННЫХ
.186	;включаем команды 186х камней.(для PUSHA и POPA)
Data Segment
err1	db	"Ошибка в воде числа.",10,13,'$'
text	db	"Введите cтроку чисел от 0 до 255",10,13,'$'
buf	db	800 	dup(?)
dva	db	2
d10	db	10
n	dw	0
x	dw	0
buffer	db	255	
stroka	dw	25 	
Data ends
;++++++++++++++++++++++++++++++++++++++++++++++++++++
;//////////////////СЕГМЕТН КОДА
;++++++++++++++++++++++++++++++++++++++++++++++++++++
Code segment
	assume cs:code, ds:data;

start:
	mov	ax,data
	mov	ds,ax

;-------Предлагаем ввести число:
	mov	ah,9h
	lea	dx,text
	int	21h

;-------Собственно сам ввод:
	mov	ah,0Ah
	lea	dx,buffer  ;в буфер записываем введеную строку.
	int	21h
	mov	si,2	;со второго байта идет сама введеная строка
	mov	cl,buffer[1] ;заносим в СХ	
	mov	ch,0         ;Длину введеной строки
;-------------------ПРОВЕРЯЕМ СТРОКУ
Prover:                        
	cmp	buffer[si],'0' ; ТУТ
	jl	erro           ; ВСЕ
	cmp	buffer[si],'9' ;ЯСНО
	jg	erro           ;!!!!
probel:
	inc	si
loop	prover

jmp	Poehali
erro:
	cmp	buffer[si],' '
	je	probel
	mov	ah,9h
	lea	dx,err1  ;в буфер записываем введеную строку.
	int	21h
JMP	QUIT	
;/*/*/*/*/*/*/*/*/*/*/*/*/*/
;ROCK-N-ROLL!
;/*/*/*/*/*/*/*/*/*/*/*/*/*/
Poehali:
	mov	al,10
	int	29h
	mov	al,13
	int	29h

;----
	mov	cl,buffer[1]
	mov	ch,0
	xor	bx,bx
	mov	di,2
;	xor	dx,dx	
POK:
	cmp	buffer[di],' '
	jg	next
	mov	si,di
	sub	si,bx
	call	StrToInt
	mov	ax,x	; АХ
	call	dec_to_bin   ;ВЫЗЫВАЕМ ПРОЦЕДУРУ ПЕРЕВОДА!!!
	mov	si,8
	call	write		
	xor	bx,bx
	jmp	lala
next:
	inc	bx
lala:
	inc	di
Loop	POK
	mov	si,di
	sub	si,bx
	call	StrToInt
	mov	ax,x	; АХ
	call	dec_to_bin   ;ВЫЗЫВАЕМ ПРОЦЕДУРУ ПЕРЕВОДА!!!
	mov	si,8
	call	write		









;cmp	dx,1
;je	net
;	mov	cl,buffer[1]
;	xor	ch,ch
;	mov	si,2
 ;
;	call	StrToInt
;	mov	ax,x	; АХ
;	call	dec_to_bin   ;ВЫЗЫВАЕМ ПРОЦЕДУРУ ПЕРЕВОДА!!!

	mov	si,8	;в si длина строки
	mov	cx,8	;в сх тоже
;-*-*-*-*-*-*-*-*-*-ВЫВОДИМ ДВОИЧНОЕ ЧИСЛО НА ЭКРАН-*-*-*-*-*-*-*-*-*-
;viv:
;	mov	al,buf[si]	;Собственно посимвольный вывод на экран
;	int	29h             ;строки.
;	dec	si              ;Строку выводим с конца.
;loop	viv
net:


;ВЫХОД в.... 
	jmp	quit
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;ПРОЦЕДУРА ПЕРЕВОДА ИЗ СТРОКИ В ЧИСЛО!
;НА Входе  buffer = введеной строке. bx - позиция
;На выходи в х помещаеться число
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

StrToInt	proc
	pusha
	mov	cx,bx
;	mov	si,2	;со второго байта идет сама введеная строка
;	mov	cl,buffer[1] ;заносим в СХ	
;	xor	ch,ch         ;Длину введеной строки
	xor	ax,ax	
per_ch:
	mov	bl,buffer[si]	;в bl ложим очередной символ строки
	sub	bl,48		;вычитаем код 0 и получаем число
	xor	bh,bh		;чтобы в ВХ было только наше число
	add	ax,bx		;складываем с АХ
	cmp	cx,1		;сравниваем СХ с 1
	jna	exx		;Если меньше или равно идeм на конец цикла		
	mul     d10		;Иначе умножаем число на 10
exx:
	inc	si		;Следующий символ
loop	per_ch	
;-------------------------------
	mov	x,ax	;в Х сохраняем значение ах
	popa		;достаем все регистры из стэка
		Ret
StrToInt	EndP
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;ПРОЦЕДУРА ПЕРЕВОДА ИЗ 10ной СИСТЕМЫ в ДВОИЧНУЮ!
;НА Входе АХ = десятичному числу. 
;На выходи в buf помещаеться двоичное число
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dec_to_bin	proc
	pusha
	mov	cx,8	;Длина строки
	mov	si,2	;со второго байта идет строка, в первых двух служебная инфа
cycl:
	div	dva	;Делим на основание системы счисления
	push	ax	;Сохраняем ах в стэке
	cmp	ah,0	;сравниваем ах с 0
	jne	ed	;если не равно то записываем в buf 1
	mov	al,48	; иначе записываем 
	mov	buf[si],al;НОЛЕГ!(код его 48;)
	jmp	exxx	;Думаю ясно;)
ed:
	mov	al,49	  ;А тут записываем еденичку
	mov	buf[si],al;КОД еденички в ASCII 49	
exxx:
	pop	ax	;достаем ах
	inc	si	;идем на следующий символ строки	
loop	cycl		;повторяем, наливаем
	POPA	
	RET
dec_to_bin	EndP

;**************************************
write	proc
PushA
;mov	si,8	;в si длина строки
mov	cx,8	;в сх тоже
viv:
	mov	al,buf[si]	;Собственно посимвольный вывод на экран
	int	29h             ;строки.
	dec	si              ;Строку выводим с конца.
loop	viv

Popa
	RET
write	endp
;УРА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;ПРИСТЕГИВАЕМ РЕМНИ, НАЛИВАЕМ ПИВО И НАСЛАЖДАЕМСЯ РАБОТОЙ ПРОГИ!!!
;УРА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
quit:
	mov	ax,4C00h
	int	21h
;*-*-*-*-*-*-*-*-*

Code ends

end start