	.model	small
	.stack	100h	
	.code
	.186	;Для команд shl al,4 и shr al,4
Delay	macro	time	
	Local	ext,inn
	push	cx
	mov	cx,time
ext:
	push	cx
	xor	cx,cx
inn:
loop	inn
	pop	cx
loop	ext
	pop	cx	
EndM

Start:
	Push	FAR_BSS	;Сегментный адрес буфера в DS
	pop	ds
;Заполняем массив ячеек случайними числами.
	xor	ax,ax 	  	;Получаем текущее время. 
	int	1Ah		;В DX - количество секунд с начала включения ПК.
	mov	di,320+200+1    ;Максимальный номер ячейки

Fill_buffer:
	imul	dx,4E35h	;Простой генератор случайных 
	inc	dx		;чисел из 2 команд.
	mov	ax,dx		;текущее случ.число заносим в ах
	shr	ax,15		;от него оставляем один бит
	mov	byte ptr [di],al;и в массив копируется 00, если ячейка пуста, и 01 если заселена.
	dec	di
	jnz	fill_buffer	;Продолжить цикл, если di не стал равен нулю
	mov	ax,0013h	;Графический режим
	int	10h		;320х200, 256 цветов.

;*******************Основной цикл*******************
new_cycle:
;1)Для каждой ячейки вычисляется число соседей 
;и записывается в старшие 4 бита этой ячейки.
	mov	di,320*200+1	;Максимальный номер ячейки
Step_1:
	mov	al,byte ptr [di+1]	;В AL вычисляется сумма значений
	add	al,byte ptr [di-1]      ;8 соседних ячеек,
	add	al,byte ptr [di+319]    ;при этом в младших 4 битах
	add	al,byte ptr [di-319]    ;накапливается число соседей
	add	al,byte ptr [di+320]
	add	al,byte ptr [di-320]
	add	al,byte ptr [di+321]
	add	al,byte ptr [di-321]
	shl	al,4           		;Теперь старшие 4 бита AL- число соседей текущей ячейки
	or	byte ptr [di],al	;Помещаем их в в старшие 4 бита ячейки.
	dec	di      		;Следующаяя ячейка
	jnz	step_1	

;******************************************************************************
;2)Изменение состояния ячеек в соответствии с получинными значениями числа соседей
;******************************************************************************
	mov	di,320*200+1	;Максимальный номер ячейки
Flip_cycle:
	mov	al,byte ptr [di];Считываем ячейку из массива.
	shr	al,4            ;Al = число соседей
	cmp	al,3            ;Если число соседей = 3
	je	birth           ;заселяем ячейку
	cmp	al,2            ;Если число соседей = 2
	je	f_c_continue    ;ячейка не изменяется
	mov	byte ptr [di],0 ;Иначе - ячейка умирает.
	jmp	short f_c_continue
birth:
	mov	byte ptr [di],1	 
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
f_c_continue:
	and	byte ptr [di],0Fh;Обнуляем число соседнй в старших битах ячейки
	dec	di      		;Следующаяя ячейка
	jnz	flip_cycle
;Вывод массива на экран спомощью BIOS
	mov	si,320*200+1    ;Макс. номер ячейки
	push	0A000h
	pop	es
	mov	cx,320+200+1
dec	dx
	mov	di,cx
	mov	si,cx
	inc	si
	rep	movsb

	mov	ah,1		;если не нажата клавиша -
	int	16h
	jz	new_cycle	;следующий шаг ~ЖИЗНИ~.
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~EXIT
	mov	ax,0003h
	int	10h	
	mov	ax,4C00h
	int	21h
	.fardata?	;Сегмент дальних неинициализированных данных
		db	320*200+1 dup(?) ; массив ячеек	
End Start