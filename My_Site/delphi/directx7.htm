<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>DirectX</title>
<meta name="Microsoft Theme" content="zero 011, default">
</head>

<body background="zertxtr.gif" bgcolor="#000000" text="#FFFFFF" link="#6699CC" vlink="#669966" alink="#999999">

<!--mstheme--><font face="Arial">
<blockquote>
<!--mstheme--></font>
<h3 align="center"><!--mstheme--><font face="Arial" color="#CCCCCC"><font color="#00FF00" size="5">DirectX
(Игровой SDK)</font><!--mstheme--></font></h3>
<!--mstheme--><font face="Arial"><!--mstheme--></font>
<h3 align="center"><!--mstheme--><font face="Arial" color="#CCCCCC">Часть 7<!--mstheme--></font></h3>
<!--mstheme--><font face="Arial"><!--// BODY -->
<b>Использование класса DDCanvas.</b>
<p>Для того, чтобы использопать этот класс,
следует скопировать модуль DDCanvas.pas ц
каталог Lib, который находится в каталоге Delphi
3.0, или и другой каталог, обозначенный в пути
поиска библиотеки.</p>
<p>Помните ли вы злополучное взаимное
исключение Win, которое приостанаилипает
многозадачную работу? Хорошо, я еще раз
подчеркну необходимость освобождения DC.
Класс TDDCanvas имеет и использует в своих целях
метод Release. Всегда заворачивайте любой
доступ к полотну в блок try..finally, например:</p>
<p><b><i>try</i></b></p>
<p><b><i>DDCanvas.TextOut( 0, 0, 'Hello Flipping World!' ) ;<br>
</i></b><i>{и т.д. }</i><b><i><br>
finally</i></b></p>
<p><b><i>DDCanvas. Release ;<br>
end ;</i></b></p>
<p>Или, как я часто делаю, используйте
конструкцию with для того, чтобы сэкономить
время набора:</p>
<p><i><b>with DDCanvas do try</b></i></p>
<p><b><i>TextOuK 0, 0, 'Hello Withering World!' ) ;</i></b><br>
</p>
<p><i>{и т.д. }</i><br>
<i><b>finally</b></i></p>
<p><i><b>Release ;<br>
end ;</b></i></p>
<p>Итак, теперь вы можете добавить пару таких
полотен в объявления формы, создавая их в
FormShow, например:</p>
<p><i>{ создать два TDDCanvas для наших двух
поверхностей }</i><br>
<b><i>PrimaryCanvas : = TDDCanvas . Create ( PrimarySurface ) ;<br>
BackCanvas : = TDDCanvas , Create ( BackBuffer ) ;</i></b></p>
<p>Освободите их в FormDestroy перед тем, как
освободить поверхности:</p>
<p><i>{ освободить объекты TDDCanvas перед
освобождением поверхностей }</i><br>
<b><i>PrimaryCanvas. Free ;<br>
BackCanvas. Free ;</i></b></p>
<p>Теперь можно осуществлять вывод либо на
основную поверхность, либо на фоновый буфер,
просто применяя эти полотна. Таким образом,
вы изменяете DrawSurfacesдля их использования,
значительно упрощая код, что
продемонстрировано<br>
в листинге 16.</p>
<p><i>Листинг 16 DrawSurfaces использует объекты
TDDCanvas.</i></p>
<p><b><i>procedure TFormI. DrawSurfaces ;<br>
var ARect : TRect ;</i></b></p>
<p><i><b>ATopPos : integer ;<br>
begin</b></i></p>
<p><i>// вначале выводить на основную
поверхность.</i><br>
<b><i>ARect := Rect( 0, 0, 640, 480 ) ;<br>
with PrimaryCanvas do try<br>
Brush. Color ;= cIRed ;<br>
FillRect( ARect ) ;<br>
Brush. Style :&lt;= bsClear ;<br>
Font. Name : = ' Arial ' ;<br>
Font. Size := 24 ;<br>
Font. Color := clWhite ;</i></b></p>
<p><b><i>ATopPos := ( 480 - TextHeight( 'A' ) ) div 2 ;<br>
Text0ut( 10, ATopPos, 'Primary surface' ) ;<br>
finally</i></b></p>
<p><i>// убедиться, что мы сразу же освободили
DC,<br>
// поскольку Windows замораживается, пока мы
владеем DC.</i><br>
<i><b>Release ;<br>
end ;</b></i></p>
<p><i>// теперь работаем с фоновым буфером</i><br>
<b><i>with .BackCanvas do try<br>
Brush. Color : = clBlue ;<br>
FillRecK ARect ) ;<br>
Brush, Style := bsClear ;<br>
Font. Name := 'Arial' ;<br>
Font. Size &#07;.=&#07; 24 ;<br>
Font. Color := clWhite ;</i></b></p>
<p><b><i>Text0ut( 630 - TextWidth( 'Back buffer' ), ATopPos, 'Back buffer' ) ;</i></b></p>
<p><b><i>finally</i></b></p>
<p><i>// убедиться, что DC освобожден</i><br>
<i><b>Release ;</b></i></p>
<p><i><b>end ;<br>
end ;</b></i></p>
<p>Заметьте блоки try...finally с вызовом Release.
Помимо этого, теперь пы добрались до этапа,
на котором уже можно рисовать на
поверхностях DirectDraw, не используя скверные
коды DirectDraw, а просто приятные методы
полотна Delphi!</p>
<p><b>Улучшение нашего изображения</b></p>
<p>Теперь, когда у вас прекрасно работает
смена страниц, самое время научиться
загружать растровое изображение на
поверхность отображения. Процесс загрузки
растрового изображения значительно
упрощен по сравнению с тем, как это
происходило в Windows 3.х, за счет введения
функций Loadimage и CreateDIBSection а WIN32 API. В Windows 95 вы
можете использовать Loadimage для загрузки
растрового изображения либо с дискового
файла, либо из ресурса. В окончательном
приложении вы несомненно встроите свои
изображения в ЕХЕ-файл в виде ресурсов.
Однако, полезно иметь возможность
загружать их из файла во время разработки.</p>
<p>Первой из них, на которую следует обратить
внимание, является DDReLoadBitmap. Вы можете смело
использовать ее без понимания того, что она
делает, но с целью обучения полезно немного
заглянуть в этот код. Бывают моменты, когда
вам может понадобиться самостоятельно
написать специализированный код по
обслуживанию растровых изображений. Это
даст вам определенное понимание того, как
это сделать. Листинг 17 представляет эту
процедуру.</p>
<p><i>Листинг 17 Сервисная процедура DDReLoadBitmap
для загрузки изображений.</i></p>
<p><i><b>procedure DDReLoadBitmap(Surface : IDirectDrawSurface ; const
BitmapName : string ) ;<br>
var Bitmap : HBitmap ;</b></i></p>
<p><b><i>begin</i></b></p>
<p><i>// попытаться загрузить изображение как
ресурс; если это не удается, то как файл</i><b><i><br>
Bitmap := Loadimage ( GetModuleHandle( NIL ), PChar( BitmapName ),</i></b></p>
<p><b><i>IMAGE__BITMAP, 0, 0, LR_CREATEDIBSECTION ) ;<br>
try<br>
if Bitmap = 0 then<br>
Bitmap := Loadimage ( 0, PChar( BitmapName ), IMA.GE_BITMAP,</i></b></p>
<p><b><i>0, 0, LR_LOADFROMFILE or LR_CREATEDIBSECTION ) ;<br>
if Bitmap = 0 then</i></b></p>
<p><b><i>Raise Exception .CreateFmt( 'Unable to load bitmap Is', [ BitmapName ]
) ;<br>
DDCopyBitmap( Surface, Bitmap, 0,0,0,0) ;<br>
finally</i></b></p>
<p><b><i>DeleteObject ( Bitmap ) ;<br>
end ;<br>
end ;</i></b></p>
<p>Вы указываете в DDReLoadBitmap поверхность DirectDraw
и имя растрового изображения, которое вы
хотите загрузить в поверхность. Процедура
сначала попытается произвести загрузку из
ресурса, предполагая, что BitmapName является
именем ресурса. Если это не удается, она
предполагает, что вы указали имя файла и
попытается загрузить его из файла. На самом
деле в этом случае при помощи Loadimage
создается секция DIB. Это Hbitmap из Windows с
форматом аппаратно независимого
растрового изображения (DIB). Вы можете
использовать DIB-секцию как обычный Hbitmap,
например, выбрав ее для DC и вызвав
стандартную функцию GDI BitBIt.</p>
<p>DDReLoadBitmap вызывает другую сервисную
программу - DDCopyBitmap, которая копирует
изображение секции DIB на поверхность DirectDraw.
Затем блок try...finally избавляется от секции DIB,
поскольку она больше не нужна. В отличие от
кода обеспечения растровых изображений
Windows 3.х, эта процедура достаточно проста.
Теперь, как по поводу DDCopyBitmap? Как показано в
листинге 18, это не намного сложнее.</p>
<p><i>Листинг 18 Сервисная процедура для
копирования растрового изображения на
поверхность.</i></p>
<p><i><b>procedure DDCopyBitmap ( Surface : IDirectDrawSurface ; Bitmap :
HBITMAP ;</b></i></p>
<p><i><b>х, y. Width, Height : integer ) ;<br>
var ImageDC : HDC ;<br>
DC : HDC ;<br>
BM ; Windows. TBitmap ;<br>
SurfaceDesc : TDDSurfaceDesc ;<br>
begin<br>
if ( Surface = NIL ) or ( Bitmap == 0 ) then</b></i></p>
<p><i><b>Raise Exception. Create ( 'Invalid parameters for DDCopyBitmap' ) ;</b></i><br>
<i>// убедиться, что поверхность
восстановлена.</i><br>
<i><b>Surfасе.Restore ;</b></i></p>
<p><i>// выбрать изображение для memoryDC, чтобы
его использовать.</i><br>
<b><i>ImageDC : = CreateCompatibleDC ( 0 ) ;</i></b></p>
<p><b><i>try</i></b></p>
<p><b><i>Select0bject( ImageDC, Bitmap ) ;</i></b><br>
<i>// получить размер изображения.</i><br>
<i><b>Get0bject( Bitinap, Size0f( BM ), @BM ) ;<br>
if Width = 0 then Width :== BM.bmWidth ;</b></i><br>
<b><i>if Height == 0 then Height :== BM.bmHeight ;</i></b><br>
<i>// получить размер поверхости.</i><br>
<i><b>SurfaceDesc.dwSize := SizeOfC SurfaceDesc ) ;<br>
SurfaceDesc.dwFlags := DDSD_HEIGHT or DDSDJWIDTH ;<br>
Surf ace .GetSurfaceDesc( SurfaceDesc ) ;<br>
if Surf ace .GetDC( DC ) &lt;&gt; DD_OK then<br>
Raise Exception. Create ( 'GetDC failed for DirectDraw surface^ )</b></i></p>
<p><i><b>try<br>
StretchBlt( DC, 0, 0, SurfaceDesc.dwWidth, SurfaceDesc.dwHeight,</b></i></p>
<p><i><b>ImageDC, x, y. Width, Height, SRCCOPY ) ;</b></i></p>
<p><i><b>finally</b></i></p>
<p><i><b>Surface. ReleaseDC ( DC ) ;<br>
end ;<br>
finally</b></i></p>
<p><i><b>DeleteDC ( ImageDC ) ;<br>
end ;<br>
end ;</b></i></p>
<p>После проверки некоторых параметров
DDCopyBitmap вызывает Restore, чтобы обеспечить
корректность память поверхности, Затем она
обращается к обычной программе Windows для
копирования растрового изображения с
одного DC на другой. Исходное растровое
изображение выбирается для первого DC,
стандартная память DC обеспечивается
вызовом CreateCompatibleDC. Передача нулевых
параметров ширины и высоты в программу
заставляет использовать фактическую
ширину и высоту растрового изображения. Для
того, чтобы получить эту информацию,
программа использует функцию GetObject</p>
<p>Затем заготавливается запись SurfaceDesc путем
включения флажков DDSD_HEIGHT и DDSD_WIDTH. Это
передает ся в GetSurfaceDesc, которое реагирует
путем заполнения полей dwHeight и dwWidth
дескриптора. Программа получает второй DC из
поверхности, используя вызов GetDC и
осуществляя простое StretchBIt Как обычно, блоки
try..-Anally используются для обязательного
освобождения DC. Все это довольно простые
вещи. Это развеивает по ветру устаревшую
истину о том, что код обработки растровых
изображений для Windows тяжело писать. К
счастью, теперь вы сможете прибегнуть к
сочинению подобного кода без чувства
опасения за будущее!</p>
<p>Kод DrawSurface упрощается еще больше, потому
что фоновый буфер теперь можно загружать
где угодно, используя DDReLoaBitmap. Упрощенный
DrawSurface представлен в листинге 19.</p>
<p><i>Листинг 19 DrawSurface без кода отрисовки
фоновой поверхности.</i></p>
<p><b><i>procedure TFormI &#07; DrawSurfaces ;<br>
var ARect : TRect ;</i></b></p>
<p><i><b>ATopPos : integer ;<br>
begin</b></i></p>
<p><i>// вывод на основное полотно.</i><br>
<i><b>ARect := Rect( 0, 0, 640, 480 ) ;<br>
with PrimaryCanvas do try<br>
Brush .Color := clBlue ;<br>
FiliRect( ARect ) ;<br>
Brush .Style :== bsClear ;<br>
Font .Name :== * Arial ' ;<br>
Font. Size :== 24 ;<br>
Font .Color := clWhite ;</b></i></p>
<p><i><b>ATopPos :^ ( 480 - TextHeight( 'A* ) ) div 2 ;<br>
Text0ut( 10, ATopPos, 'Primary surface' ) ;</b></i></p>
<p><i><b>finally</b></i></p>
<p><i>// убедиться, что мы сразу же освободили
DC,<br>
// поскольку Windows замораживается, пока мы
владеем DC.<br>
<b>Release ;<br>
end ;</b></i></p>
<p><i>{ загрузить изображение в фоновый буфер }</i><br>
<b><i>DDReloadBitmap( BackBuffer, GetBitiilapName ) ;<br>
end ;</i></b></p>
<p><b>А что по поводу палитр?</b></p>
<p>Я знал, что об этом вы обязательно бы меня
спросили! Хорошо, мы все еще вынуждены
работать с палитрами. Настало время
представить еще один СОМ-объект DirectDraw, На
этот раз это lDirectDrawPalette. Этот маленький
полезный объект обслужит большинство
компонент палитры, нс утруждая этим нас с
вами. Для того, чтобы использовать IDirectDraw,
высоздаете его с IDirectDraw.CreatePalette, которая
устанавливает указатель на массив вводимых
данных палитры, который использовался для
инициализации объекта палитры. Затем вы
присоединяете ее к поверхности DrawSurface и она
станет использоваться автоматически для
всех последующих операций. Конечно же,
прекрасно.</p>
<p>Итак, как же получить эти значения цветов?
Хорошо, я написал еще одну небольшую
функцию для их загрузки из растрового
изображения или создания цветов по
умолчанию, и для создания и возврата
объекта IDirectDrawPalette. Она<br>
также находится в DDUtils.pas и называется
DDLoadPalette. Вы просто передайте ей имя вашего
объекта IDirectDraw либо с именем растрового
изображения, либо (если вы хотите палитру по
умолчанию) с пустой строкой. (Как и другие
программы,<br>
DDLoadPalette сначала пытается загрузить
растровое изображение из ресурса
приложения. Если это не удается, она
пытается загрузить растровое изображение
из файла. Я не повторяю здесь код, поскольку
он несколько длиннее других функций. Он
главным образом имеет дело с проверкой
наличия у DIB таблицы цветов, которую он
затем копирует в массив вводимыхданных
палитры).</p>
<p>Я добавил объект палитры к объявлению
формы, загрузил его в FormShow и присоединил
объект палитры к основной поверхности
следующим образом:</p>
<p><i>{ загрузить палитку иэ растрового
изображения и присоединить ее к основной
поверхности }</i><br>
<b><i>DDPalette : = DDLoadPalette ( DirectDraw, GetBitmapName ) ;<br>
PrimarySurface , SatPalette ( DDPalette ) ;</i></b></p>
<p>Создав, вы должны освободить его из
основной поверхности в FormDestroy:</p>
<p><i>{ освободить DD-палитру }</i><br>
<b><i>if Assigned ( DDPalette ) then DDPalette. Release ;</i></b></p>
<p>Проделав все изменения, вы можете теперь
приступить к проверке. DDDemoS содержит все
изменения, обозначенные до настоящего
момента.</p>
<p><b>Объединение всего вместе</b></p>
<p>В настоящий момент вы можете составить
DirectDraw-приложсние со сменой страниц, а также
загрузить растровое изображение и палитру.
У вас имеется все необходимое для создания
смены страниц и причем на полной скорости!
Для того, чтобы было еще интересней, как
насчет анимации? DirectDraw в одной из
демонстрационных программ использует файл
с именем ALL.BMP. Вы также скачать его вместе с
примером DDDenno5. В ней содержится еще одно
более интересное<br>
фоновое изображение и набор анимационных
кадров с красным вращающимся трехмерным
тором.</p>
<p>Перед очередной сменой страницы вы
захотите отобразить фоновое изображение и
затем текущий анимационный кадр с тором. Вы
создаете три тора в разных позициях на
экране, которые будут вращаться с разной
скоростью. Ввиду того, что<br>
фоновый буфер будет непрерывно
перерисовываться, вы должны хранить где-нибудь
еще исходное изображение, загруженное из
ALL.BMP. Поэтому создайте для него еще одну
поверхность DirectDraw. Это внеэкранная
плоскость и она не имеет отношения к смене
страниц; на ней мы будем хранить
изображение.</p>
<p>Существенно важно отметить, что по
умолчанию DirectDraw создает исходное
изображение в экранной памяти. Это означает,
что когда вы используете изображение для
обновления фонового буфера, любой
производимый битовый перенос использует
аппаратный перенос битов, если таковой
имеется на графической карте. Практически
все персональные компьютеры в настоящее
время оснащены ускоренной графической
картой, которую как раз и использует DirectDraw.
Ввиду того, что это аппаратное обеспечение
работает намного быстрее, чем процессор во
время битового переноса, игры DirectDraw должны
иметь большую эффективность по отношению к
играм DOS, где процессор делает все.</p>
<p>Битовый перенос (bit-blitting) - термин,
используемый для описания переноса
областей растровых изображений в, из или в
пределах других растровых изображений.
Термин иногда записывается более точно как
bitblting, но он сложен для чтения, поэтому вы
часто найдете его в расчлененным в виде
двух слов bit-blitting. BitBIt - краткое описание
термина BITmap Block Transfer (перенос блока
растрового изображения).</p>
<p>Итак, за работу. Создайте эту
дополнительную поверхность и назовите ее
Image (изображение). Добавьте ее в объявление
формы. Это как раз и есть IDirectDrawSurface, поэтому
нет необходимости представлять здесь эту
тривиальную строку кода. Затем добавьте код
в FormShow, который создает растровое
изображение. Используйте DDLoadBitmap, это только
одна строка! Вот она:<br>
<i><b>Image := DDLoadBitmap (Directdraw, GetBitmapName, О, О);</b></i></p>
<p>Помните, что вам необходимо пополнить
метод RestoreSurfaces и тогда вы получите новую
неявную поверхность. Если восстановление
основной памяти поверхности пройдет
нормально, попытайтесь восстановить
поверхностную память Image. Если оба типа
восстановлений будут иметь место, вызовите
DrawSurfaces, как показано в листинге 20.</p>
<p><i>Листинг 20 Восстановление всех
поверхностей.</i></p>
<p><b><i>function TFormI. RestoreSurfaces : HResult ;<br>
begin<br>
Result := primarySurface. Restore ;<br>
if Result = DD OK then begin<br>
Result := Image-Restore ;<br>
if Result = DD_OK then DrawSurfaces<br>
end ;<br>
end ;</i></b></p>
<p>Пока все... </p>
</blockquote>
<p align="right"><b>Автор статьи:</b>&nbsp; <a href="mailto:ogion@stud.vsu.ru">Стас
Бакулин</a></p>
<!--mstheme--></font>

</body>

</html>
