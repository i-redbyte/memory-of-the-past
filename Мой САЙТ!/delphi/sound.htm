<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Аналог функций Sound</title>
<meta name="Microsoft Theme" content="zero 011">
</head>

<body background="zertxtr.gif" bgcolor="#000000" text="#FFFFFF" link="#6699CC" vlink="#669966" alink="#999999">

<!--mstheme--><font face="Arial"><!--mstheme--></font>
<h3><!--mstheme--><font face="Arial" color="#CCCCCC"><font color="#00FF00">Аналог
функций Sound() и NoSound() под WindowsNT/2k/XP</font><!--mstheme--></font></h3>
<!--mstheme--><font face="Arial"><!--// BODY -->
<p align="right">файлы к статье: <a href="http://www.delphimaster.ru/articles/ntbeep/ntbeep.zip">ntbeep.zip</a></p>
<!--mstheme--></font>
<h4><!--mstheme--><font face="Arial" color="#CCCCCC">Вступление,
или Для чего я все это затеял.<!--mstheme--></font></h4>
<!--mstheme--><font face="Arial">
<p align="justify">&nbsp;&nbsp;Те, кто работал с Паскалем,
помнят, что там были функции Sound() и NoSound() для
работы со спикером. Переход на Delphi повлек за
собой утрату этих функций. Необходимость
работы со спикером не часто, но возникает.
Недавно мой друг попросил меня написать
программу для тренировки реакции: аналог
таймера в брейн-ринге. Принцип ее прост:
пользователь нажимает кнопку, запускается
таймер с задержкой равной 3000 + random(5000)
миллисекунд. После этой задержки звучит
звуковой сигнал (в течение одной секунды). С
момента начала звукового сигнала идет
отсчет времени и пользователь может нажать
клавишу для остановки таймера. Отрезок
времени между началом звукового сигнала и
нажатием клавиши представляет собой время
реакции. При этом, если время реакции меньше
одной секунды (трудно не успеть нажать
клавишу за секунду), то звуковой сигнал
должен прекратится. Обязательным условием
было возможность работы со спикером.
<p align="justify">&nbsp;&nbsp;Вроде бы все просто. На
самом деле реализовать все это под Windows 9x/ME
не составило труда. Работа со спикером на
ассемблере описана чуть ли не на каждом
форуме по программированию. А вот под NT/2k/XP
возникла проблема: апишная функция Beep()
позволяет пищать заранее определенное
время. Использование ассемблера не
проходит: спикер это устройство, к которому
программы в user-mode не имеют доступа.<!--mstheme--></font>
<h4><!--mstheme--><font face="Arial" color="#CCCCCC">Начинаю поиски<!--mstheme--></font></h4>
<!--mstheme--><font face="Arial">
<p align="justify">&nbsp;&nbsp;Не знаю, почему, но первое,
что пришло мне в голову, это создать нить,
которая вызывает Beep(dwFrequency, 1000) и, как только
пользователь остановит таймер, грохнуть ее.
Такой метод работал и не плохо. Но я
подозревал, что это есть не хорошо (это
вообще не едят :)), так как закрытие нити
может оставить за повлечь за собой утечку
памяти или незакрывание каких-либо хендлов.
Просмотрев процесс с помощью Process Explorer, я
заметил, что после каждого закрытия нити
появляется незакрытый хендл файла-устройства
&quot;\Device\Beep\&quot;. Я полез в Форум на Мастерах
Дельфи. Ничего того, что могло бы мне помочь,
среди ответов предложено не было. Было одно
предложение, о котором я тоже думал: крутить
в цикле Beep(dwFrequncy, 1) до тех пор пока не
кончится секунда или пользователь не
остановит таймер. Но этот прием довольно
плохо сказывается на производительности,
да и на медленных машинках звук получался
прерывистым. Посему, лезу в Kernel32.dll, в
которой находится функция Beep().<!--mstheme--></font>
<h4><!--mstheme--><font face="Arial" color="#CCCCCC">В дебрях
Kernel32.dll<!--mstheme--></font></h4>
<!--mstheme--><font face="Arial">
<p align="justify">&nbsp;&nbsp;Воспользовавшись
дизассемблером, например W32Dasm, мы можем
посмотреть листинг функции Beep (). Изучение
нескольких строк в начале листинга дает
понять, что динамически грузится какая-то
библиотека и вызывается функция
_WinStationBeepOpen():<!--mstheme--></font>
<pre>* Reference To: KERNEL32.LoadLibraryW
                                  |
:77EAA54A E89047FEFF              call 77E8ECDF
:77EAA54F 3BC6                    cmp eax, esi
:77EAA551 7410                    je 77EAA563

* Possible StringData Ref from Code Obj -&gt;&quot;_WinStationBeepOpen&quot;
                                  |
:77EAA553 682C28EA77              push 77EA282C
:77EAA558 50                      push eax
* Reference To: KERNEL32.GetProcAddress
                                  |
:77EAA559 E8EDB0FEFF              call 77E9564B
:77EAA55E A39409EE77              mov dword ptr [77EE0994], eax
</pre>
<!--mstheme--><font face="Arial">
<p align="justify">&nbsp;&nbsp;Описание этой функции я
так нигде и не нашел. Но, рассматривая
листинг далее<!--mstheme--></font>
<pre>:77EAA56F 6AFF                    push FFFFFFFF
:77EAA571 FFD0                    call eax
</pre>
<!--mstheme--><font face="Arial">решил, что эта функция
принимает всего один параметр, и тот равен
0xFFFFFFFF.
<p align="justify">&nbsp;&nbsp;Далее можно найти
обращение к функции RtlInitUnicodeString(). Это
документированная функция и она нужна для
того, чтобы заполнить структуру UNICODE_STRING,
которая будет использоваться в NtCreateFile().
NtCreateFile() - тоже документирована (DDK). Она
создает/открывает файлы, драйвера,
устройства, пайпы и еще кучу всякой ерунды.
Хендл устройсва, полученного в результате
данной функции используется в NtDeviceIoControlFile(),
которая используется для управления
устройствами. Далее устройство закрывается
с помощью NtClose(). Я не стал разбирать листинг
далее, так как работа с устройством не этом
заканчивалась, а начиналась установка
системных параметров (таких как код ошибки
и еще чего-то). Не знаю, зачем используется
GetConsoleDysplayMode(), NtCreateKey(), и не представляю, что
выполняет CsrClientCallServer(). Собственно, для меня
это было не важно.<!--mstheme--></font>
<h4><!--mstheme--><font face="Arial" color="#CCCCCC">Начинаем
писать<!--mstheme--></font></h4>
<!--mstheme--><font face="Arial">
<p align="justify">&nbsp;&nbsp;Сразу хочу сказать, что все
примеры привожу на Си. Этому есть несколько
причин и одна из них то, что описания вех
функций и структур сделано на Си. Перед
написанием я просмотрел NTDDK, в котором нашел
файл ntddkbeep.h. Он был очень полезен. Я не стал
подключать различные модули из NTDDK, так как
тот же ntddk.h плохо удивается с windows.h, который
я использовал, да и просто не хотелось, ведь
все равно функции NtXxxx там не описаны. Я
подключил лишь ntddkbeep.h и написал main.h, в
который скопировал все необходимые
описания и константы. После этого пишу
консольное приложение, в котором грузятся
библиотеки winsta.dll (в ней находится
_WinStationBeepOpen) и NTDLL.dll (все NtXxx и RtlInitUnicodeString).
После этого узнаем адреса всех необходимых
функций. Сначала делаем _WinStationBeepOpen(0xFFFFFFFF) -
не знаю зачем, без нее все равно все
работает, но раз в Beep() есть, то пусть и у нас
будет. Потом заполняем необходимые
структуры: для UNICODE_STRING uniName используем
RtlInitUnicodeString(). Далее вызываем NtCreateFile(). После
чего NtDeviceIoControlFile(). Вот в этот момент
используется один, как говорят математики,
искусственный прием: длительность сигнала
ставим 0xFFFFFFFF, то есть он будет пищать более 8
лет. Как только мы вызовем NtCose() драйвер
выгрузится и, если написан не криво,
освободит все используемые ресурсы, а звук
прекратиться. Этого я и добивался. Надо не
забыть выгрузить библиотеки.
<p align="justify">&nbsp;&nbsp;Вроде бы все. Вопрос закрыт.
Описания функций можно найти в MSDN.
<p align="justify">P.S. Не знаю, где будут лежать <a href="http://www.delphimaster.ru/articles/ntbeep/ntbeep.zip">исходники</a>.
Я их переслал модератору сайта, с просьбой
вставить в самое начало статьи ссылку на
них, но если что, то пишите на мыло r_a_vic@rambler.ru
<p align="justify">P.P.S.: Ночь уже, через два дня
экзамен, а я ерундой занимаюсь.
<p align="right">(C) Рябухин Александр, 09.06.2003. По
всем вопросам пишите r_a_vic@rambler.ru</p>
<!--mstheme--></font>

</body>

</html>
