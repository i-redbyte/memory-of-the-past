<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>DirectX</title>
<meta name="Microsoft Theme" content="zero 011, default">
</head>

<body background="zertxtr.gif" bgcolor="#000000" text="#FFFFFF" link="#6699CC" vlink="#669966" alink="#999999">

<!--mstheme--><font face="Arial"><!--mstheme--></font>

<h3 align="center"><!--mstheme--><font face="Arial" color="#CCCCCC"><font color="#00FF00" size="5">DirectX (Игровой SDK)</font><!--mstheme--></font></h3>
<!--mstheme--><font face="Arial"><!--mstheme--></font>
<h3 align="center"><!--mstheme--><font face="Arial" color="#CCCCCC">Часть 3-4<!--mstheme--></font></h3>
<!--mstheme--><font face="Arial">
<!--// BODY -->
<b>Поверхности отображения</b>
<p>Теперь вы готовы создавать поверхности
отображения. В DirectDraw поверхность
отображения представляет собой линейную
область экранной памяти, к которой можно
получить непосредственный доступ для
манипуляций. Поверхность отображения,
которую вы видите на экране, называется
основной поверхностью. Она представляет
память видимого кадрового буфера на карте
отображения. Вы также можете иметь
невидимые поверхности, которые
определяются как внеэкранные, или
оверлейные поверхности. Подобное может
существовать либо в регулярной системной
памяти, либо во внеэкранной области памяти
на самой графической карте. Для того, чтобы
создать ситуацию с мелькающими страницами,
необходима основная поверхность и, по
крайней мере, одна внеэкранная поверхность
для осуществления отображения. Для того,
чтобы внеэкранная поверхность могла
появляться и исчезать на экране, онадолжна
находится в видеопамяти. Тем не менее, DirectDraw
пытается создать поверхности в видеопамяти
по умолчанию, поэтому нет необходимости
предпринимать что-либо специально.</p>
<p>Существует способ для создания основной
поверхности и одной и более сменных
поверхностей в одно и то же время за счет
создания комплексной поверхности. Еще один
аспект в создании комплексной (составной)
поверхности заключается в том, что вы
можете освободить все поверхности в
комплексной цепи сменных поверхностей
путем высвобождения самой комплексной
поверхности. Для примера создадим
комплексную поверхность посредством одной
вспомогательной буферной поверхности.</p>
<p>Фоновые поверхности, которые создаются в
качестве части комплексной, известны как
Неявные поверхности. Существует большое
число операций, которые вы не сможете
осуществить с помощью Неявных поверхностей,
например, отсоединить их от основной
поверхности или освободить их независимо
от основной поверхности. Однако,
комплексные поверхности намного проще
создавать, потому что DirectDraw создает фоновые
буфера и соединяет их с основной
поверхностью.</p>
<p>В этой связи я должен затронуть вопрос
сложности DirectDraw, поскольку необходимо
заполнять поля и записи TDDSurfaceDesc. Если вы
прочитаете об этом и справке DirectDraw, вы
сможете увидеть, что все это выглядит
довольно ужасно! Но<br>
как я уже говорил, вы можете счастливо
игнорировать большинство из этих полей.
Листинг 4 представляет код, который
необходимо добавить в обработчик OnShow для
создания комплексной поверхности.</p>
<p><i>Листинг 4 Создание комплексной
поверхности.</i></p>
<p><i>{ заполнить описатель DirectDrawSurface перед
созданием поверхности }<b><br>
FillChar( DDSurfaceDesc, Si2e0f( DDSurfaceDesc ), 0 ) ;<br>
with DDSurfaceDesc do begin<br>
dwSize := SizeOf ( DDSurfaceDesc ) ;<br>
dwFlags := DDSD_CAPS or DDSD_BACKBUFFERCOUNT ;<br>
ddSCaps.dwCaps := DDSCAPS_COMPLEX or DDSCAPS FLIP or</b></i></p>
<p><i><b>DDSCAPS_PRIMARYSURFACE ;<br>
dwBackBufferCount : = 1 ;<br>
end ;</b></i></p>
<p><i>Листинг 7 Тестирование нажатия клавиш
Escape и F12.</i></p>
<p><i><b>procedure TForml.ForinKeyDown (Sender: TObject; var Key: Word;<br>
Shift: TShiftState) ;</b></i></p>
<p><i><b>begin</b></i></p>
<p><i>// если нажаты клавиши Escape или F12,
завершить приложение<b><br>
case Key of</b></i></p>
<p><i><b>VK_ESCAPE, VK_F12 : Close ;<br>
end ;</b></i></p>
<p><i><b>end;</b></i></p>
<p>Вы можете скачать этот пример u DDDemo3 здесь.
Если вы запустите его, иы уиидите на экране
мелькание сменяющих друг друга
поверхностей GDI, которые содержат формы
размером с экран, и фоновый буфер, который,
вероятно, заполнен различными битами &quot;остатков&quot;
отображения. Помните, для выхода следует
нажать Esc или F12 (или конечно же Alt+F4).<br>
</p>
<p><b>Получение доступа к фоновому буферу</b></p>
<p>Теперь, когда вы познали основы
приложения смены страниц, вы, вероятно,
захотите что-нибудь с ним сделать. Вы
нуждаетесь в том, чтобы иметь возможность
рисовать на поверхности фонового буфера.
Однако, в последней секции вы создали
комплексную поверхность, которая
автоматически создала для нас фоновый
буфер. Проблема заключается в том, что
функция CreateSurface заполнила поле PrimaryField (основная
поверхность), и вы должны получить доступ к
фоновому буферу. Для этого можно вызвать
метод GetAttachedSurface. Добавьте поле фонового
буфера BackBuffer к форме и код из листинга 8 - к
OnShow:</p>
<p><i>Листинг 8 Доступ к поверхности фонового
буфера.</i></p>
<p><i>{ получить фонов зй буфер }<b><br>
DDSCaps . dwCaps : = DDSCAPS_BACKBUFFER ;</b></i></p>
<p><i><b>if PrimarySurface.GetAttachedSurface( DDSCaps, BackBuffer ) &lt;&gt;
DD_OK then<br>
Raise Exception. Create ( 'Failed to get back buffer surface' ) ;</b></i></p>
<p>DDSCaps является локальной переменной типа
TDDSCaps, которая добавляется к обработчику
FormShow. Вы заполняете флажки для необходимой
присоединенной поверхности и вызываете
GetAttachedSurface. В этом случае вам необходим
фоновый буфер. Метод может вернуть только
одну поверхность. Вызов напрасен, если
более чем одна присоединенная поверхность
соответствует переданным флажкам DDSCaps.
Однако, не имеет значения, сколько фоновых
поверхностей вы создали, существует только
одна поверхность с флажком фонового буфера,
и она является первой в цепи сменных
поверхностей после основной. Если
необходимо получить все присоединенные
поверхности, можно вызвать функцию
EnumAttachedSurfaces.</p>
<p><b>Восстановление поверхностей</b></p>
<p>Одна из многих особенностей DirectDraw
заключается в том, что поверхности могут
потерять свою память по многим причинам;
например, когда изменяется режим
отображения. Если это происходит, вы должны
вызвать метод Restore поверхности, чтобы
получить свою память обратно. Вы также
должны перерисовать поверхность. Это
несколько напоминает то, как у вас
возникает необходимость нарисовать окно в
обычном программировании для Windows, когда
оно перекрывается и нуждается в обновлении.
Большинство из функций IDirectDrawSurface могут
возвратить результат DDERR_SLIRFACELOST. Когда это
происходит, вы должны восстановить
поверхность и перерисовать ее. Многие из
этих функций также могут вернуть
DDERR_WASSTILLDRAWING, что по сути означает, что
аппаратное обеспечение занято и запрос
необходимо повторять до тех пор, пока вы не
добьетесь успеха, или пока вы не получите
иное сообщение об ошибке.</p>
<p>Вот основополагающая логическая схема,
использующая метод Flip. Этот пример
предназначен только для того, чтобыввести
вас в курс. Он не перерисовывает
поверхности. Смотрите листинг 9.</p>
<p><i>Листинг 9 &quot;Традиционный&quot; код для
проверки и восстановления поверхности.</i></p>
<p><i><b>repeat</b></i></p>
<p><i><b>DDResult := PrimarySurf асе. Flip ( NIL, 0 ) ;<br>
case DDResult of<br>
DD_OK : break ;<br>
DDERR_SURFACELOST : begin<br>
DDResult := PrimarySurface. Restore () ;<br>
if DDResult &lt;&gt; DD_OK then break ;<br>
end ;</b></i></p>
<p><i><b>else if DDResult &lt;&gt; DDERR_WASSTILLDRAWING then break<br>
end ;<br>
until false ;</b></i></p>
<p>Самое надоедливое то, что вам необходим
подобный код практически для каждого
вызова метода IDirectDrawSurface. Всякий раз, когда
спецификация вызова в справке Game SDK
содержит DERR_SLJRFACELOST в качестве возможного
результата, это необходимо. Но Pascal-структурированный
язык высокого уровня, не так ли? Таким
образом, почему бы не написать небольшой
сервисный метод для оказания такой помощи?
Вот этот метод с именем одного из моих
любимых шоу. (Оно не дает возможности себя
забыть!) Оно представлено в листинге 10.<br>
</p>

<p align="right"><b><a href="directx5-6.htm"><font color="#FFFF00">Следующая
страница&gt;&gt;</font></a></b></p>
<!--mstheme--></font>

</body>

</html>
