<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Невизуальные классы в Delphi</title>
<meta name="Microsoft Theme" content="zero 011, default">
</head>

<body background="zertxtr.gif" bgcolor="#000000" text="#FFFFFF" link="#6699CC" vlink="#669966" alink="#999999">

<!--mstheme--><font face="Arial">
<blockquote>
<!--mstheme--></font>
<h3 align="center"><!--mstheme--><font face="Arial" color="#CCCCCC"><font color="#00FF00" size="5">Невизуальные
классы в Delphi</font><!--mstheme--></font></h3>
<!--mstheme--><font face="Arial"><!--// BODY -->
<p align="justify">В этом обзоре мне хотелось бы
осветить несколько классов Delphi, которым
обычно в книгах и других обучающих
материалах уделяется (если уделяется)
весьма скромное внимание. Это так
называемые невизуальные классы, не
порожденные непосредственно от <b>TComponent</b> и
не имеющие владельца. Следовательно,
начинающий разработчик в палитре
компонентов их не видит, в книжках о них не
пишут, а help’ы ему читать неохота или он
просто не знает английского… Так уж
получается что RAD не способствуют обучению
работы с невизуальными классами, что плохо
отражается как на квалификации такого <i>программиста</i>,
так и на предлагаемых им программных
решениях. Отсюда и множество вопросов из
разряда FAQ задаваемых по этой теме в
конференциях.</p>
<p align="justify">Итак, наиболее подробно я хочу
остановиться на трех классах
инкапсулирующих список (<b>TList</b>), поток
данных (<b>TStream</b>) и поток приложения (<b>TThread</b>).</p>
<p align="justify">Начнем с класса <b>TList</b>. Это
удачное решение программистов Borland, которое
реализует большинство возможностей для
работы со связными списками
нетипизированных указателей. Список – это
наиболее гибкая структура данных, которая
позволяет хранить в индексированном виде
объекты <b><i>разных</i></b> типов. Массив
нетипизированных указателей размещается в
куче.</p>
<p align="justify">Этот класс обеспечивает
индексированный доступ к элементам списка,
позволяет добавлять и удалять элементы
списка, менять объекты местами и
сортировать объекты.</p>
<p align="justify"><b>TList</b> имеет всего четыре
свойства, из которых полезными для нас
являются два:</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>property</b>
Count: Integer; - определяет количество элементов
списка</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>property</b>
Items[Index: Integer]: Pointer; - индексированный массив
указателей на объекты.</p>
<p align="justify">Эти два свойства служат для
доступа к объектам списка. Обратите
внимание, что многие из объектов,
построенных с использованием списков, для
доступа к своим элементам используют
аналогичные свойства (<b>TStrings</b>, <b>TStringGrid</b>, <b>TListView</b>
и другие).</p>
<p align="justify">Стоит также отметить свойство
Capacity. Если вы заранее знаете количество
элементов в списке, то стоит присвоить это
значение свойству Capacity.</p>
<p align="justify">Методов у класса <b>TList</b> заметно
больше чем свойств. Рассмотрим наиболее
важные из них:</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>function</b>
Add(Item: Pointer): Integer; - добавляет объект в список.
Указатель на объект указывается как
параметр функции. Стоит отметить, что
большинство объектов в Delphi уже являются
указателями. Так, переменная <b>Form1: TForm</b>,
является указателем на объект <b>Form</b>. В
отличие от <b>Borland Pascal for DOS</b>, в Delphi в этом
случае не применяется запись <b>^TForm</b>.</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>procedure</b>
Clear; dynamic; - как следует из названия, очищает
список, при этом удаляются все ссылки на
объекты и занимаемая ими память. Счетчик <b>Count</b>
устанавливается в нуль. Сами объекты должен
удалить программист используя, например,
метод Dispose.</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>procedure</b>
Delete(Index: Integer); - удаляет заданный индексом
элемент из списка. Элементы нумеруются
начиная с 0! Следующие за удаленной записью
элементы, смещаются на один «вверх».</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>procedure</b>
Exchange(Index1, Index2: Integer); - вспомогательная
функция, используется для обмена местами
двух элементов списка.</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>function</b>
IndexOf(Item: Pointer): Integer; - определяет, является ли
конкретный указанный объект элементом
списка, и если это так, возвращает его
индекс.</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>procedure</b>
Insert(Index: Integer; Item: Pointer); - вставляет объект в
список на место, указанное параметром <b>Index</b>.</p>
<p align="justify">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>procedure</b>
Sort(Compare: TListSortCompare);</p>
<p align="justify"><b>type</b> TListSortCompare = <b>function</b> (Item1, Item2:
Pointer): Integer;&nbsp;<br>
Данная процедура весьма удобное средство
для сортировки списка.</p>
<p align="justify">Непосредственно для сравнения
двух элементов списка используется
пользовательская функция, которая
возвращает результат сравнения на основе
тех или иных свойств. В процедуре
сортировки используется метод QuickSort,
который дает достаточно хороший результат (по
скорости) на реальных данных. Хотя при «неблагоприятных»
данных он проигрывает методу пирамидальной
сортировки. В случае такого рода данных
процедуру сортировки можно написать самому
используя метод Exchange.</p>
<p align="justify">При написании функции Compare
следует учесть, что при работе с большими
наборами данных эта процедура может
вызываться до сотен тысяч раз во время
работы приложения и занимать существенную
часть времени его выполнения. Для решения
этой проблемы следует по возможности
оптимизировать работу этой функции. Для
этого полезным будет знать несколько
наиболее «быстрых» функций:</p>
<p align="justify">для сравнения текста:</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompareStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
– для регистрозависимого текста</p>
<p align="justify">CompareText&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - для
регистронезависимого текста</p>
<p align="justify">для сравнения дат</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompareFileTime&nbsp; -
даты в системном формате</p>
<p align="justify">для сравнения регионов</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EqualRgn</p>
<p align="justify">другие</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EqualRect,</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EqualSid,</p>
<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IShellFolder::CompareID.</p>
<p align="justify">&nbsp;</p>
<p align="justify">Следующая остановка – потоки
данных. В Delphi есть несколько видов потоков
– файловый поток, поток в памяти, поток
связанный с handle объекта, строковый поток и т.д.
Все они унаследованы от своего
абстрактного предка <b normal?>TStream</b>.
Разобравшись с ним вы сможете единообразно
работать с любыми другими потоками.</p>
<p align="justify">Поток - это некоторая обобщенная
модель двоичных данных</p>
<p align="justify">У базового класса есть два
свойства, унаследованные всеми потомками:
Position и Size, которые определяют позицию в
потоке и его размер, соответственно.</p>
<p align="justify">Рассмотрим основные функции
класса. Если вы уже работали с файлами, то
обращение к этим методам весьма схоже:</p>
<p align="justify"><b>function</b> Read(<b>var</b> Buffer; Count: Longint):
Longint; <b>virtual</b>; <b normal?>abstract</b>; - читает данные
из потока в буфер;</p>
<p align="justify"><b>function</b> Write(<b>const</b> Buffer; Count: Longint):
Longint; <b>virtual</b>; <b normal?>abstract</b>; - пишет данные в
поток;</p>
<p align="justify"><b>function</b> Seek(Offset: Longint; Origin: Word): Longint;
<b normal?>virtual</b>; <b>abstract</b>; - устанавливает
позицию в потоке.</p>
<p align="justify">Как видите все очень просто. Суть
же в том, что <b><i>с использованием потоков
можно единообразно работать с памятью,
файлами, строками</i></b> и т.д.</p>
<p align="justify">Есть и пара просто полезных
функций</p>
<p align="justify"><b>function</b> CopyFrom(Source: TStream; Count: Longint):
Longint; - эта функция копирует часть или весь
поток из другого потока. Этим методом,
например, очень удобно копировать файлы.
Есть мнение, что работа с потоками, быстрее
работы с файлами. К сожалению у меня не было
возможности проверить это утверждение…</p>
<p align="justify"><b>procedure</b> SaveToFile(<b>const</b> FileName: <b>string</b>);
- позволяет сохранить участок памяти в
дисковый файл.</p>
<p align="justify">&nbsp;</p>
<p align="justify">Теперь мы подошли к одному из
самых мощных, полезных и удобных решений –
инкапсуляции потоков в Delphi. Понятие потока
представлено программистами Borland в виде
абстрактного класса TThread Каждый
разработчик может унаследовать от него
свой поток, наделив его нужной
функциональностью. Все проблемы по
управлению потоками, их синхронизации и т.д.
остаются на долю VCL. В рамках данной статьи я
не берусь подробно описать и объяснить все
механизмы и тонкости задействованные при
работе с потоками и все же отошлю вас к
литературе данной в конце статьи, а сам же
дам лишь обзор потоков.</p>
<p align="justify">Итак, когда и зачем используются
потоки? Что это такое? Потоки – это объекты,
которым процессор выделяет время. Обратите
внимание, не процессам или программам, а
порожденным им потокам. Так что любая
программа содержит в себе хотя бы один
поток. Он называется главным. С появлением
потоков появилась возможность отдавать для
решения каждой задачи ровно столько
ресурсов, сколько ей нужно. Для этого
используется понятие приоритета потока.
Каждый процесс имеет свой приоритет (от
фонового до реального времени). В рамках
процесса существуют потоки, приоритетом
которых (потоков) может управлять процесс.
Таким образом приоритет может иметь
значение от 0 до 31. Следует заметить, что
программы написанные в <span lang="EN-US" EN-US?>Delphi по
умолчанию порождают процесс с нормальным
приоритетом (он может быть переднего или
заднего плана, в зависимости от активности
задачи и меняться от 9 до 7). Процессы
реального времени используются крайне
редко.</p>
<p align="justify">Чтобы сделать свой поток, вам
нужно унаследовать свой класс от объекта
TThread. Это можно сделать из меню File -&gt; New…
Будет создан модуль с заготовкой для класса.
Все что вам нужно сделать – перекрыть метод
Execute. Для этого его нужно объявить как <b>override</b>
и наделить нужной функциональностью.</p>
<p align="justify">При написании метода Execute нужно
учесть следующее: поток работает
параллельно с основным потоком программы и
может обращаться к каким-то элементам или
компонентам &nbsp;также параллельно с
основным потоком. Чтобы избежать этого,
нужно использовать метод Synchronize. В его
параметре следует указать действия,
производимые с «общими» объектами.
Например</p>
<p align="justify">Synchronize(MainForm.Label1.Caption:=’Hello!’);</p>
<p align="justify">изменит надпись на форме и не
вызовет аварийной ситуации или ситуации
гонок, когда два процесса пытаются
захватить один и тот же ресурс.</p>
<p align="justify">Процесс может находиться в двух
состояниях – выполняться или быть
приостановленным. За это отвечают методы</p>
<p align="justify"><b>procedure</b> Suspend;</p>
<p align="justify"><b>procedure</b> Resume;</p>
<p align="justify">Также процесс может
самоуничтожаться по завершении - свойство
FreeOnTerminate.</p>
<p align="justify">Метод</p>
<p align="justify"><b>function</b> WaitFor: LongWord; ожидает
завершения потока.</p>
<p align="justify">&nbsp;</p>
<p align="justify">Вот вкратце и все, что я хотел
рассказать. Этот обзор не претендует на
полноту. Он призван подтолкнуть начинающих
изучать Delphi к более глубокому
проникновению в возможности этой среды
программирования. Почти половина
информации из этой статьи взята мной из help-файла,
поставлявшегося с Delphi. Чаще в него
заглядывайте! Читайте книги. Знакомьтесь с
эхоконференциями. Смотрите исходники
программ. И все у вас получится!</p>
<p align="justify">&nbsp;</p>
<p align="right">Александр Бакулин, 27.02.2000</p>
<!--mstheme--></font>
<h4><!--mstheme--><font face="Arial" color="#CCCCCC">Для
ознакомления<!--mstheme--></font></h4>
<!--mstheme--><font face="Arial">
<p align="justify">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; П. Драхвелидзе,
Е. Марков «Delphi 4 Среда визуального
программирования», БХВ – Санкт-Петербург,
1999</p>
<p align="justify">2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Фаронов В.В. «Delphi
3 Учебный курс», Нолидж, 1998</p>
<p align="justify">3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Эхоконференции
<b>RU.DELPHI.*</b></p>
Очень хорошо приемы работы с потоками и
проблемы которые возникают при их
использовании описаны в книге П.
Драхвелидзе и Е. Маркова «Delphi 4 Среда
визуального программирования» изданной в «БХВ
– Санкт-Петербург».
<p>&nbsp;</p>
<!-- BODY //-->
</blockquote>
</span><!--mstheme--></font>

</body>

</html>
