; Выводить в одно место экрана введённый символ до тех пор пока не будет введён; 
; другой символ. Менять при выводе атрибут символа циклически от 1 до 15. Для  ;
; анализа нажатия клавиши использовать вектор 1Ch.                             ;
;==============================================================================;

; Сегмент стека
stk segment stack
    db 0100h dup (?)
stk ends
;---------------------------------

; Сегмент данных
data segment
Old_1C_seg dw (?)      ; Сегмент старого обработчика вектора 1Ch
Old_1C_offs dw (?)     ; Смещение старого обработчика вектора 1Ch

; Координаты вывода
YCoord dw 5            ; Вертикальная координата
XCoord db 20           ; Горизонтальная координата
ElemSize db 2          ; Число байт под один символ на экране
Symbol db (?)          ; Символ для вывода
data ends
;---------------------------------

; Сегмент кода
code segment
assume cs: code, ds: data, ss: stk

;-------------------------------------------------------------------------------
; Обработчик прерывания 1Ch
Int_1C_proc proc far 
; Сохранить данные из регистров в стеке
push ax
push bx
push cx
push dx

push ds

; Настройка на сегмент данных программы
mov ax, data
mov ds, ax

; Была ли нажата кнопка на клавиатуре
mov ah, 0Bh
int 21h

cmp al, 0FFh       ; Если символа нет то выходим из прерывания
jne No_Symb

mov ah, 08h        ; Снимаем символ из буфера клавиатуры
int 21h
mov Symbol, al


No_Symb:

; Восстановить регистры из стека
pop ds

pop dx
pop cx
pop bx
pop ax

iret    ; Возврат из прерывания
Int_1C_proc endp
;-------------------------------------------------------------------------------
; Точка входа в основную программу
start:
; Настройка на сегмент данных программы
mov ax, data
mov ds, ax


;---------------
; Получаем адрес старой подпрогаммы обработки прерывания
mov ah, 35h
mov al, 01Ch
int 21h

; Сохраняем сегмент и смещение старого вектора прерывания
mov Old_1C_seg, es
mov Old_1C_offs, bx

;---------------
;Устанавливаем новый вектор

push ds

mov dx, offset Int_1C_proc 
mov ax, seg Int_1C_proc

mov ds, ax
mov ah, 25h
mov al, 1ch
int 21h

pop ds

mov ax,  0B800h
mov es, ax   	  ; В ES начало видеопамяти в текстовом режиме

xor cx, cx        ; CX = 0
mov cl, XCoord    ; В CL горизонтальная координата вывода символа
xor bx, bx        ; BX = 0
inc bh            ; BH = 1 (атрибут выводимого символа)

Infinity_Loop:
; Вычисляем координаты символа в памяти
xor ax, ax        ; AX = 0
mov al, 80        ; Число символов в строке
mul ElemSize      ; 80*2 (умножаем на размер элемента)
mul YCoord        ; 160*Y
add ax, cx        ; 160*Y + X
mov di, ax        ; DI = AX
mov bl, Symbol    ; В BL помещаем выводимый символ

mov ES:[di], bx   ; Вывод символа на экран

cmp bh, 15        ; Сравниваем bh с 15 (атрибут выводимого символа)
jl Less           ; Если меньше 15 - переходим на метку Less
mov bh, 1         ; bh = 1
Less:
inc bh            ; Увеличиваем bh на 1

cmp Symbol, 27    ; Если был нажат Escape - выходим из программы
je quit
jmp Infinity_Loop

; Выход из программы
quit:
; Восстанавливаем старый вектор
push ds
mov dx, Old_1C_offs
mov ax, Old_1C_seg
mov ds, ax
mov ah, 25h
mov al, 1ch
int 21h

pop ds

mov ax, 04C00h
int 021h

code ends
end start
ок

Должно быть mov ES: [di]