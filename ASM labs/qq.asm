;СЕГМЕНТ ДАННЫХ
.186	;включаем команды 186х камней.(для PUSHA и POPA)
Data Segment
err1	db	"Ошибка в воде числа.",10,13,'$'
text	db	"Введите число.",10,13,'$'
buf	db		8 dup(?)
dva	db	2
d10	db	10
x	dw	0
buffer	db	4	
Data ends
;++++++++++++++++++++++++++++++++++++++++++++++++++++
;//////////////////СЕГМЕТН КОДА
;++++++++++++++++++++++++++++++++++++++++++++++++++++
Code segment
	assume cs:code, ds:data;

start:
	mov	ax,data
	mov	ds,ax

;-------Предлагаем ввести число:
	mov	ah,9h
	lea	dx,text
	int	21h

;-------Собственно сам ввод:
	mov	ah,0Ah
	lea	dx,buffer  ;в буфер записываем введеную строку.
	int	21h

;********************************
;*Преобразовываем строку в число*
;********************************
	mov	si,2	;со второго байта идет сама введеная строка
	mov	cl,buffer[1] ;заносим в СХ	
	mov	ch,0         ;Длину введеной строки
	xor	ax,ax
per_ch:
	mov	bl,buffer[si]	;в bl ложим очередной символ строки
	sub	bl,48		;вычитаем код 0 и получаем число
	xor	bh,bh		;чтобы в ВХ было только наше число
	add	ax,bx		;складываем с АХ
	cmp	cx,1		;сравниваем СХ с 1
	jna	exx		;Если меньше или равно идeм на конец цикла		
	mul     d10		;Иначе умножаем число на 10
exx:
	inc	si		;Следующий символ
loop	per_ch	
;-------------------------------
	mov	x,ax	;в Х сохраняем значение ах
	popa		;достаем все регистры из стэка
	mov	ax,x	;востанавливаем значение АХ
;в АХ находиться введеное число	
	call	dec_to_bin   ;ВЫЗЫВАЕМ ПРОЦЕДУРУ ПЕРЕВОДА!!!

	mov	si,8	;в si длина строки
	mov	cx,8	;в сх тоже
;-*-*-*-*-*-*-*-*-*-ВЫВОДИМ ДВОИЧНОЕ ЧИСЛО НА ЭКРАН-*-*-*-*-*-*-*-*-*-
viv:
	mov	al,buf[si]	;Собственно посимвольный вывод на экран
	int	29h             ;строки.
	dec	si              ;Строку выводим с конца.
loop	viv


;ВЫХОД в.... 
	jmp	quit
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;ПРОЦЕДУРА ПЕРЕВОДА ИЗ 10ной СИСТЕМЫ в ДВОИЧНУЮ!
;НА Входе АХ = десятичному числу. 
;На выходи в buf помещаеться двоичное число
;/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*
;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dec_to_bin	proc
	mov	cx,8	;Длина строки
	mov	si,2	;со второго байта идет строка, в первых двух служебная инфа
cycl:
	div	dva	;Делим на основание системы счисления
	push	ax	;Сохраняем ах в стэке
	cmp	ah,0	;сравниваем ах с 0
	jne	ed	;если не равно то записываем в buf 1
	mov	al,48	; иначе записываем 
	mov	buf[si],al;НОЛЕГ!(код его 48;)
	jmp	exxx	;Думаю ясно;)
ed:
	mov	al,49	  ;А тут записываем еденичку
	mov	buf[si],al;КОД еденички в ASCII 49	
exxx:
	pop	ax	;достаем ах
	inc	si	;идем на следующий символ строки	
loop	cycl		;повторяем, наливаем
	
	RET
dec_to_bin	EndP
;УРА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;ПРИСТЕГИВАЕМ РЕМНИ, НАЛИВАЕМ ПИВО И НАСЛАЖДАЕМСЯ РАБОТОЙ ПРОГИ!!!
;УРА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
quit:
	mov	ax,4C00h
	int	21h
;*-*-*-*-*-*-*-*-*

Code ends

end start